# -*- coding:utf-8 -*-
# @Time: 2021/10/1 下午3:24
# @Author: Elvin
'''
引用计数：实时性高，只要引用计数为0，对象就会被销毁，内存被释放，回收内存的的时间平摊到了平时

标记清除：
1.标记阶段：GC会把所有活动对象打上标记，这些活动的对象就如同一个点，他们之间的引用关系构成边，最终点个边构成了一个有向图
2.搜索清除阶段：从根对象（root）出发，沿着有向边遍历整个图，不可达的对象就是需要清理的垃圾对象。这个根对象就是全局对象，调用栈，寄存器

分代回收：代回收，根据内存中对象的存活时间将他们分为3代，新生的对象放入到0代，如果一个对象能在第0代的垃圾回收过程中存活下来，GC就会将其放入到1代中，如果1代里的对象在第1代的垃圾回收过程中存活下来，则会进入到2代。

'''

import gc

print(gc.get_threshold())

'''
当分配对象的个数减去释放对象的个数的差值大于700时，就会产生一次0代回收
10次0代回收会导致一次1代回收
10次1代回收会导致一次2代回收

对于第0代的对象来说，他们很可能就被使用一次，因此需要经常被回收。

经过一轮一轮的回收后，能够活着成为第2代的对象，必然是那些使用频繁的对象，而且他们已经存活很久的时间了，大概率的，还会存活很久，因此，2代回收的就不那么频繁，
'''
#设置三个阈值，改变分代回收的触发条件
import gc

gc.set_threshold(600, 10, 5)
print(gc.get_threshold())
